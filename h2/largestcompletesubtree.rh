//rhythm code; (hw2) largest complete subtree in binary tree

fun treenode(v) {
    return {
        "value": v,
        "left": nil,
        "right": nil
    };
}

fun findlargestsubtree(currentnode, bestnode, bestdepth) {
    
    if(currentnode == nil)
    {
        //base case; empty subtree is considered complete with height =0
        return 
        {
            "height":  -1, 
            "bestnode": bestnode, 
            "bestdepth": bestdepth
        }; 
    }

    //recursion ; check left and right subtrees and get heights
    var left = findlargestsubtree(currentnode.left,bestnode,bestdepth); 
    //update variables (since i pass by ref in orig c++ code) 
    bestnode = left.bestnode; 
    bestdepth= left.bestdepth; 
    var leftheight = left.height; 

    //same recursion for right subtree
    var right = findlargestsubtree(currentnode.right, bestnode, bestdepth); 
    bestnode = right.bestnode; 
    bestdepth = right.bestdepth; 
    var rightheight = right.height; 


    //find the smaller subtree
    var smaller = leftheight; 
    if(rightheight< leftheight)
    {
        smaller = rightheight; 
    }

    var height = 1+ smaller; 

    //if current node has the largest complete subtree so far 
    if(height > bestdepth) 
    {
        bestdepth = height; 
        bestnode = currentnode; 
    }

    //return as map since passed by ref in orig c++ code 
    return 
    {
        "height": height, 
        "bestnode": bestnode, 
        "bestdepth":bestdepth
    }; 

    return 0;
}


fun main() {

    //change this to test diff inputs 

//                n1
//               /  \
//             n2    n3
//            /     /  \
//          n4     n5    n6
//                / \    / \
//              n7  n8  n9 n10
//             / \ / \  / \ / \
//           n11 n12 n13 n14 n15 n16 n17 n18
//


    var n1 = treenode(1);
    var n2 = treenode(2);
    var n3 = treenode(3);
    var n4 = treenode(4);
    var n5 = treenode(5);
    var n6 = treenode(6);
    var n7 = treenode(7);
    var n8 = treenode(8);
    var n9 = treenode(9);
    var n10 = treenode(10);
    var n11 = treenode(11);
    var n12 = treenode(12);
    var n13 = treenode(13);
    var n14 = treenode(14);
    var n15 = treenode(15);
    var n16 = treenode(16);
    var n17 = treenode(17);
    var n18 = treenode(18);

    n1.left = n2;   n1.right = n3;
    n2.left = n4;

    n3.left = n5;   n3.right = n6;
    n5.left = n7;   n5.right = n8;
    n6.left = n9;   n6.right = n10;

    n7.left = n11;  n7.right = n12;
    n8.left = n13;  n8.right = n14;
    n9.left = n15;  n9.right = n16;
    n10.left = n17; n10.right = n18;

    var root = n1;

    //change this to test diff inputs 



    //pass to function and output 
    var bestnode = nil;
    var bestdepth = 0;
    var height = findlargestsubtree(root, bestnode, bestdepth);

    //have to unpack returned values
    bestnode = height.bestnode; 
    bestdepth = height.bestdepth; 

    printf("largest complete subtree depth: %d\n", bestdepth);
    printf("root of complete subtree: %d\n", bestnode.value);

}

main(); 